# 简介

## 写在前面

在介绍这款工具之前, 我们先简单了解下什么是`Store`? 顾名思义, 有`商店`, `仓库`的作用。 一般在项目中处理 **全局状态管理(组件间状态传递)**、**视图/服务解耦** 的问题, 同时也具备一定的**存储管理能力**。在`vuex`的定义中, `Store`是一种 **状态管理模式**, 通过状态驱动视图更新。

在实际的开发中, 引入 `Store` 模式一般用来解决以下几种问题场景.

-   处理组件间复杂的参数传递问题.
-   维护全局状态. 如: 用户 `token` 的维护.
-   服务抽象. 如: 解耦 `支付`, `用户态管理`等复杂服务.
-   解决中大型项目协作问题. (ps: 本质上, 仍然是服务抽象问题)
-   以及提供一些扩展功能, 如: `持久化`, `orm映射`等.

## 介绍

Flat design store util, 意为**扁平化设计的 Store 工具**. 作为一款`Store`工具, 通过`Class API`的设计来改进 Store 模式在 typescript 下的开发体验。

> 推测由于存量用户及依赖更少的 API 等因素,不论是`vuex` 还是 `Pinia`都采用的是`Option API`来定义 Store.而使用 Object 编程对于 typescript 的类型推断等功能的不太友好. 虽然`Pinia`的出现对于 ts 支持有了一定程度的改善, 但由于仍然是`Option API`编程, 对习惯使用`Class API` 写法来说, 仍然不太友好.

## 什么情况下使用?

当你的项目存在以下几种情况, 建议使用`@fdu/store`作为你的 Store 层支撑工具.

-   项目采用 class 方式定义组件脚本 (尤其是这种情况, 建议从`vuex`切换到`@fdu/store`)
-   只想通过引入 Store, 来解决**服务抽象**, **全局状态管理** 问题.
-   需要处理复杂的数据持久化问题, 如: 需要持久化某个模块、需要持久化某个字段.
-   前端新人, 想通过 Store 模式来解决项目管理问题, 但苦于`vuex`,`pinia`等框架功能复杂, 学习成本高导致很难上手.

## 特性

`@fdu/store` 作为`Store`的支撑工具。 由 3 部分组成, 分别为: `Store`、`Adapter`(适配器)、`Plugin` (插件)

-   **Store**

    -   极简, 通过 `StoreManager`, `StoreModule` 提供状态管理和持久化能力.
    -   API 风格, 大体上与`vuex`保持一致, 同时精简了一部分 API.
    -   持久化能力, 支持按模块、按字段持久化数据 (按需持久化).

-   **Adapter (适配器)**

    由于 Store 模式具备普适性, 且这个工具在这方面有极高的自由度. 所以, 为了方便起见, 将 `vuex` 中携带的响应式操作, 从核心代码中解耦出来. 提供有 Adapter 接口, 可根据项目环境(框架, 版本)按需选择.

-   **Plugin (插件)**

    非框架核心能力即表现为插件, 工具提供 Plugin 接口, 扩展能力均通过插件实现, 根据项目需求按需引用.

::: tip
对于为什么内置持久化能力, 其他能力通过插件集成, 请参考[笔记](../../notes/1.md)
:::

### 优点

> 在了解 `vuex` API 的基础上, 只需掌握基础的 typescript 和 es 特性, 即可上手。

-   极低的上手成本
-   极高的扩展性
-   更友好的 typescript 支持
-   方便的持久化能力
-   扁平化设计
-   插件支持: 加密, devTool(状态快照, 时间旅行), 自定义签名, 自定义数据源...
-   API 及概念上, 保持与`vuex`一致. 并精简了一些复杂 API.

### 局限性

由于类型推断(提示)功能的存在, 需要一定程度上依赖 IDE 和 typescript 提供支持. 在 js 项目中使用时, 对比 ts 仍有一定差距.
