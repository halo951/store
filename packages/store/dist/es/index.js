/** @cp0/store
 *
 * @author halo951
 * @license MIT
 */
import t from"set-value";import{klona as e}from"klona";class s{__parent__;storage;PERSISTENCE_KEYS;getData;get parent(){return this.__parent__}get state(){return this.getData?.()}constructor(t){t&&(this.storage=t)}$commit(t,e,s){}$patch(t,e){}$clear(){}}const r=(t,e={})=>{const s=e.separator||".",r="/"!==s&&e.preservePaths;if("string"==typeof t&&!1!==r&&/\//.test(t))return t;t instanceof Array&&(t=t.join(s));let i="";for(let e=0;e<t.length;e++){const r=t[e];if("\\"!==r){if(r===s||"["===r)break;i+=r}else i+=t[++e]}return i},i=(t,e,s)=>{for(const r of s)if(!e[r])throw new Error(`${t} ${r} is required.`)};class o{options;ready;cache={keys:{},data:{}};get modules(){return Object.keys(this).filter((t=>this[t]instanceof s))}constructor(t){this.options={version:"1.0.0",...this.options,...t}}install(t){return this.init(),t?(this.options.adapter&&this.options.adapter.factory(this,t),this.emit((e=>e.onBinded?.(this,t))),this):this}$clear(t){if(!((t=t??this.modules)instanceof Array))throw new Error("$store.clear() should be passed into Array.");let e;for(const s of t)e=this[s],this.cache.data[s]=e.initData(),this.persistence(s,e)}init(){if(this.ready)return;let t;this.emit((t=>t.onBefore?.(this)));for(const e of this.modules)t=this[e],i(`$store.${e}`,t,["initData"]),this.injectFactory(e,t),this.prepare(e,t);this.ready=!0,this.emit((t=>t.onReady?.(this)))}generateModuleSign(t){return this.emit(((t,e,s)=>t.transformSign?t.transformSign(e,s):e),t)}injectFactory(e,s){const i=`$store.${e} `;s.__parent__=this,s.getData=()=>this.cache.data[e]??{},s.$commit=(o,n,a)=>{const c=r(o);if(!this.cache.keys[e].includes(c))throw new Error(i+`'${c}' is not defined.`);t(this.cache.data[e],o,n,a),this.persistence(e,s)},s.$patch=(o,n)=>{if(!o)throw new Error(i+"$patch must has 'data'.");if("object"!=typeof o||o instanceof Array)throw new Error(i+"$patch's data should is IData.");const a=Object.keys(o).map((t=>r(t))).filter((t=>!this.cache.keys[e].includes(t)));if(a.length>0)throw new Error(i+`${JSON.stringify(a)} is not defined.`);for(const s in o)t(this.cache.data[e],s,o[s],n);this.persistence(e,s)},s.$clear=()=>this.$clear([e])}prepare(t,e){const s=this.generateModuleSign(t),r=e.storage?.getItem(s)??null,i=e.initData();let o={};if(r){const t=JSON.parse(r);t?.version===this.options.version&&(o=this.emit(((t,e,s)=>t.transformPrepare?t.transformPrepare(e,s):e),t.data))}this.cache.keys[t]=Object.keys(i),this.cache.data[t]={...i,...o},this.persistence(t,e)}persistence(t,e){const s=this.generateModuleSign(t),r=this.cache.data[t],i=e.storage,o=e.PERSISTENCE_KEYS;let n,a={};if(!i||!o)return;for(const t in r)n=o.includes(t)&&void 0!==r[t],n&&void 0!==r[t]&&(a[t]=r[t]);a=this.emit(((t,e,s)=>t.transformPersistence?t.transformPersistence(e,s):e),a);const c={data:a,version:this.options.version};null==a||"object"==typeof a&&0===Object.keys(a).length?i.removeItem(s):i.setItem(s,JSON.stringify(c))}emit(t,s){let r=e(s);if(!(this.options.plugins instanceof Array))return r;for(const e of this.options.plugins)r=t(e,r,s);return r}}export{o as StoreManager,s as StoreModule};
