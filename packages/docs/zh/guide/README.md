# 介绍

`@fdu/store` 完整含义为`flat design store util`, 即扁平化设计的 store 工具。 是一个面向 Class API 范式编程的 Store 工具, 希望借助 typescript 特性, 优化 Store 的编程体验。

## 特性

-   **极简**

    -   仅需掌握 typescript 一般特性(继承, 抽象, 泛型) 和 es 的一些新特性(getter/setter) 即可上手。

-   **更大地想象空间**

    -   **跨框架/跨平台设计(<font style="color: #ff5b5b;">不再局限于 vue</font>)** - 通过 adapter 设计, 可以扩展不同平台下的响应式支持。不论是`vue`, `react`,`小程序`均可采用一致性方案解决问题.
    -   **按需持久化特性** - 支持**按模块**, **按字段**, **指定命名空间**组合的持久化方式
    -   **扩展** - 工具采用侵入性极低地注入方式提供能力. 允许通过继承、装饰器等能想到的各种方式去扩展更多能力.

-   **开发体验**

    -   提供有 vue-devtool 插件, 支持**状态快照**, **时间旅行**能力 (@fdu/store-plugin-devtool)
    -   提供 组合式 API 支持 (@fdu/store-composition-api)

-   **插件机制**

    -   提供丰富
    -   Store lifecycle 的每一个阶段均涵盖 插件插槽, 支持插件链式调用.

> 注: 受 Class API 的设计影响, 在 HMR 方面表现不是很好, 这是目前可见地最大的局限性.

## 什么情况下使用?

当你的项目存在以下几种情况, 建议使用`@fdu/store`作为你的 Store 层支撑工具。

-   涉及多种应用场景, 且想整合不同平台下前端应用的架构设计
-   希望通过 Class API, 提供更好的代码可读性和 IDE 的推断能力
-   需要处理复杂的前端数据持久化问题, 如: 指定模块, 指定字段的持久化.
-   需要处理**服务抽象**, **全局状态管理** 问题

## 对比 pinia

2022 年推出的 pinia, 上述 vuex 的问题基本都解决掉了, 另外新增了`this`指向以及不错的`Composition API`支持。

|                 | @fdu/store                                    | pinia                                |
| --------------- | --------------------------------------------- | ------------------------------------ |
| 学习成本        | 掌握 typescript                               | 仍然有一些特性 API 需要学习          |
| 跨框架/跨平台   | adapter 设计, 理论上 js 环境下都能支持        | 强依赖 vue                           |
| 数据持久化特性  | 支持按需持久化, 可扩展加密,命名空间等特殊操作 | 插件集成                             |
| API 设计        | Class API                                     | Options API                          |
| 类型推断支持    | 原生(基于继承、抽象实现)                      | 通过类型继承方式实现                 |
| 组合式 API 支持 | <font color="red">需要使用插件扩展</font>     | 原生支持                             |
| 多 Store 支持   | 比较友好, 参考[多 Store 支持](.)              |                                      |
| 状态变化监控    | 提供有 devTool, 观察者插件                    | 默认支持 devTool, 及提供变化监听事件 |
| 文档            | 灰常拉跨 -.-                                  | 牛皮 🐮                              |

> 从对比 pinia 来看, `@fdu/store` 最明显的特点在于他不需要额外去学习复杂的设计理念, 甚至除了`initData`外, 没有其他强约束的 API 结构, 从学习成本上来说, 是优于 pinia 的.
> 另外一点, 相比于 Options API 范式, 使用 Class API 范式在可读性方面, 更加直观, 两者间的取舍建议根据项目情况自行决定。

## 这个项目怎么来的?

不知道各位小伙伴有没有刚上手 vuex 时, 被各种特性 API 折磨过的经历. 举两个例子:

vuex 的参数变更和操作是通过 arguments 实现的, 比如 `getters` 、 `mutaitons` ,`actions` 定义中, 都需要通过方法的第一个参数获取`state` 或者是`context`, 非常不方便。这里感觉一方面是因为`Options API`的局限性。 另一方面, 考虑会不会是因为项目创建阶段的问题. `getter/setter` 语法是 es6 后面才引入的关系。

另外是, 对 ts 类型推断的设计不够友好, 比如: `dispatch`需要通过字符串指定 action 行为, 无法通过 ts 静态检查来规避代码错误.
