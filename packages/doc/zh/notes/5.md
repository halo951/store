# 为什么不实现根据不同 vue 版本, 默认集成响应式方案?

> 标题只是引述, 后续拆分 2 个文档.

在创作这个工具之初, 响应式设计是参考 vuex 通过 mixin 写入到 vue 实例中的, 但是在 vue3.x 中, 关于全局变量(Option Api)及响应式配置方式发生了改变. 然后, 改写了一版, 通过 vue-demi 方式, 实现不同版本的适配. 这是初期的设计.

后面, 因为将原本集成到工具里面的能力(module 签名, 加密) 这些功能进行插件化改造. 类似 vuex 减重操作. 发现, 在处理响应式时, 通过 vue-demi 方式不够平滑, 就很突兀. 所以, 干脆将这部分能力, 改造为适配器接口, 拆分 vue2.x vue3.x 的响应式实现, 并且移除 vue-demi。

同时, 这么做也有另外一方面考虑, 因为 Store 层在`@fdu/store`的概念中, 主要处理业务形态的数据(不论是全局状态管理, 还是 actions), 所以它与框架(render framework) 是弱耦合的关系, 理论上来讲, 只要是实现响应式,

那么将这个工具放到`react`, `小程序` 等一些其他环境下, 都可以使用. 进而达到另外一种更高阶的设计. 将应用拆分为 `视图层(UI)`,`服务层(Service/数据&业务处理)`, `通信及其他能力`。顾名思义, 视图层由`Vue`等 UI 框架提供, 这也是目前`Vue`,`React` 这些框架的趋势, 专注做一个视图管理和渲染工具, 并且将其他能力解耦. 然后, 再 `服务层` 中, 通过`@fdu/store` 解决服务管理和全局状态维护问题.

对于前端项目而言, 这么操作之后, 可以实现在不考虑框架语言(Vue,React...)学习成本的情况下, 掌握 Typescript(js 也可) 即能完成前端非界面渲染以外的功能开发。能够极大的解放生产力.
